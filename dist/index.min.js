module.exports = ({ errorArray: e = [], dataSource: r = [], defaultErrorMessage: t = '' }) => { let o = !0; const n = {}; const i = t ? { msg: t } : ''; const s = (e, r, t, o) => { const n = t.shift(); const i = n === 'index' ? r : n; t.length !== 0 ? (e[i] = {}, s(e[i], r, t, o)) : e[i] = o }; return e.forEach(((e) => { if (!Array.isArray(e?.condition) && !e?.customCondition) return console.error(`Invalid type \`${typeof !e?.condition}"\` supplied to parameter "condition", expected \`array\`;\n          type \`${typeof !e?.customCondition}"\` supplied to parameter "customCondition", expected \`function        `); if (typeof e?.index !== 'string') return console.error(`Invalid type \`${typeof e?.index}"\` supplied to parameter "index", expected \`string\`!`); if (e?.customCondition) { n[e.index] = []; const t = []; if (e.customCondition(r, t), !Array.isArray(t)) return console.error(`Invalid type \`${typeof t}"\` return from parameter "customValidation", expected \`array\`!`); if (t.length) { const r = t.length > 1; let a = r ? [] : null; t.forEach(((t, n) => { let c = !0; t || (c = !1, o = !1); const d = {}; let l; const p = c ? null : e?.errorMessage ? { msg: e?.errorMessage } : i; if (e?.errorFormat && p) { const t = e?.errorFormat.slice(); s(d, n, t, p), l = Object.keys(d).length === 0 ? null : d, r ? a.push(l) : a = l } else r ? a.push(p) : a = p })), n[e.index] = a } } else { !e.condition.every(((e) => !1 !== e)) || (n[e.index] = e?.errorMessage ? { msg: e?.errorMessage } : i, o = !1) } })), [o, n] }
// # sourceMappingURL=index.min.js.map
